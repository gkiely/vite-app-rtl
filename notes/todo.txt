- Setup routes for machine
  - setup routing
  - cancel all actors on route change

- Exiting a state should cancel the spawned actors

- Write an `update` function that takes the place of assign
  - It assigns
  - It sendsParent for that key

https://github.com/statelyai/xstate/discussions/2599#discussioncomment-2535584
https://spectrum.chat/statecharts/general/routing-with-xstate~51467af4-f834-41af-9dce-75b8059a702e
https://spectrum.chat/statecharts/general/the-xstate-router-and-the-use-router-machine-hook~85ff5e23-ec7f-4c7a-af58-b0b58009ccf3
https://sawyerh.medium.com/routing-using-state-machines-3c797988d68e
https://xstate.js.org/docs/guides/actors.html#spawning-machines

- File xstate bug for actions: [] or actions: {} with spawn via codesandbox

// Concepts
// A top level routerMachine
// A machine for each route (routeMachine)
// Each routeMachine state can use machines via invokeMachine
// - And listen via onContextUpdate or onStateUpdate
// - Similarly the top level routerMachine can listen via onContextUpdate or onStateUpdate

// The nice thing about this approach:
- There is a machine for each route, route gets state and context
- Each state can use a machine, instead of a nested state node
- Machines can be written normally
  - Machines can have their own context

const routerMachine = {
  context: {
    count: 0,
    posts: [],
  },
  states: {
    '/': {
      invoke: {
        id: '/',
        src: routeMachines['/'],
        data: (context) => context,
      },
      on: {
        update: {
          actions: assign((context, event) => ({
            store: {
              ...context,
              ...event.payload.data,
            }
          }),
        }
      }
    },
    // Simplified
    'second-route': invokeMachine(homeRouteMachine, {
      data: (c) => c,
      onContextUpdate: (context, event) => ({
        count: event.payload.data.count,
        posts: event.payload.data.posts,
      })
    })
  }
}


const homeRouteMachine = createMachine({
  context: {
    count: 0,
    posts: [],
    someOtherValueThatWontSync: 0,
  },
  states: {
    // Maps all the states of the sub machine to this machine and keeps them in sync
    // It will have to return the states of the child, invoke the machine, listen for 'state.update' and call send on the parent
    posts: invokeMachine(postsMachine, {
      onContextUpdate: ((context, event) => ({
        posts: [...context.posts, ...event.payload.data],
      }),
    }),

    // Would look something like this
    posts: {
      invoke: [
        {
          id: postsMachine.id,
          src: postsMachine,
        }
      ],
      on: {
        'invokeMachine.context.update': {
          actions: assign((context, event) => ({
            store: {
              ...context,
              ...event.payload.data,
            }
          }),
        },
        'invokeMachine.state.update': {
          actions: send((c, e) => ({
            type: e.payload.type,
            data: e.payload.data,
          }))
        }
      },
      states: {
        ...postsMachine.getSnapshot().config.states,
        // loading: {},
        // success: {},
        // error: {},
      }
    }
  }
})


const routeMachines = {
  '/': homeRouteMachine
}




Next
- Push to cloudflare pages
- Get server rendering working
  - Switch off js x
  - Server render initial page x
  - Get img path working
    - Setup webpack config for worker: https://developers.cloudflare.com/workers/wrangler/cli-wrangler/webpack/
    https://developers.cloudflare.com/workers/wrangler/configuration/
    - If you can't get it working easily enough, just get it working with node and move on
  - Get css styles working
  - Wrap entire UI in a form
  - All actions are links with query params for actions
  - State is stored in a form?
    <form>
      <button type="submit" value="{ count: 1 }">Click</button>
    </form>

- Replace client/server in useRoute and all app.request with a generic request function

- Drive the front end using curl requests
- Test loading bar
  loading && { component: 'LoadingBar' }
  https://github.com/klendi/react-top-loading-bar
- See if setRoute can be moved to routes.tsx
- Pending actions
  - Avoid duplicate requests when interacting
- Write a request module, that handles communication and requires handling these types:
https://youtu.be/NLcRzOyrH08?t=758

- Add typing for action payloads
- Do a document explaining how the client side server/api works

- Create a version that works with a machine: feature/machine
  - Make adding/removing posts go via the api and take 1s

- Make a version of send that works with the server
  - Hits API
  - API updates server store
  - Returns response
  - Send then hits the route
  - Don't worry about loading states, it should just wait

- Write your own minimal hono library to allow sub 1ms click update
  - currently it's 2-3ms, w/o the async call it's .1-.5ms
- Write your own minimal zod library to avoid the large bloat

- Remove sections and components, just use an array
- Create a time travel debugger down the bottom
  - Debugger component that can be dropped in to any route

- hono on the client?

- Setup db/store object and req obj for each route

- Instead of actions living in the route
  - UI calls API
  - The api updates the global db and responds
  - UI requests new json once request completes
    - Each route has access to req, db, user
  - See if you can Hono to work locally as well as server
  - Each route should get req, db, user
    - req: hono req
    - db: all state stored in memory
    - user: user data
  - Server
    - routes
    - components  



- Render a second page with the prev routes posts

  Some options:
  - Current route calls nextRoute with appropriate state, which then calls onEnter
  - onEnter has access to state
  - Global store

- Array support for routes names ['', '/']
- Server render / and add to readme (client and server rendering)
- Use a machine instead of reducer

Then
- Add error boundary
- File typescript bug for object spread

- Write an eslint plugin to require a catch block for async
- Add type builder for hono

- Allow actions
- Allow using machines
- Ability to go from update -> createMachine

- Front end deploy to pages
- Server deploy to workers


V2
- Write a client router that behaves the same way as hono, currently it takes .3-.5ms to respond
- Rewrite types from scratch


- Setup time travel debugging
- Add a check for combining reducers, making sure duplicate actions aren't used
- Ability to create sub routes
  - Essentially I can break out an existing route, create a new one and have it be used
    - I will have to think about how this would work with send
    - Either via passing the prop to the component, or potentially having sub routes via the url, that then direct where they are sent
      /home
      /home/posts
  - Ability to createRenderer in render function

Later
- Setup node vite plugin so node updates trigger a hot module reload
- Try miniflare instead of wrangler? Or just wait until js api is supported in wrangler
https://github.com/cloudflare/miniflare
https://github.com/cloudflare/wrangler2/issues/771
